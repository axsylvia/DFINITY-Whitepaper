# 2 架构概述

如图1所示，IC协议包括四层：

- P2P层（详见第4章）
- 共识层（详见第5章）
- 路由层（详见第6章）
- 执行层（详见第7章）

链钥加密技术(chain-key crytography)在多个层都有应用，将分别在第3章和第8章中详细介绍其阈值签名(threshold signatures)和链升级(chain-evolution)技术

## 2.1 P2P层

P2P层的任务在子网的共识节点中传递协议消息。协议消息包括

- 共识消息
- 外部用户发起的输入消息

P2P层基本上提供的是一个“最有效的”广播通道

&emsp;&emsp;*如果一个诚实的共识节点广播了一条消息，那么这条消息最终将会被子网中的所有诚实节点所接受。*

&emsp;&emsp;P2P层的设计目标如下：

- **资源限制.** 所有的算法都在有限的资源(内存，带宽，CPU)下运转。
- **消息优先级.** 根据特定的属性(例如类型，大小和轮次)，不同的消息将按照不同的优先级进行排序。并且这些优先级的规则可能随着时间将会改变。
- **效率.** 高吞吐量比低延迟更重要。
- **抗DOS/SPAM.** 故障节点将不会影响诚实共识节点间的相互通信

## 2.2 共识层

IC共识层的任务是对输入消息进行排序，以确保所有的共识节点按照相同的顺序处理输入消息。现在已有很多科研中的协议是为了解决这一问题。IC采用了一种全新的共识协议，本文将用概括性的语言对其进行阐述。

&emsp;&emsp;任何安全的共识协议都应当确保两个属性，大体上就是：

- **安全性：** 所有的共识节点都事实上同意相同的输入顺序
- **活性：** 所有的共识节点都应当逐一更新状态

&emsp;&emsp;IC共识层的设计目标

- 极简
- 健壮：当存在个别恶意节点时，性能会柔性下降

&emsp;&emsp;如前所述，我们假设作恶节点f<n/3(即拜占庭容错)。同时，IC在部分同步网络的假设下可以确保协议的活性，而协议的安全性甚至在完全的异步网络下依然可以保证。

&emsp;&emsp;像许多的共识协议一样，IC共识协议是基于区块链。伴随着协议的进程，以创世区块为根节点的区块树将不断生长。每一个非创世区块都包含一个有效负载(payload)，由一系列输入和父块的哈希组成。诚实的共识节点对这个区块树有一致的视角：尽管每个共识节点可能对这个区块树有不同的局部视角，但是所有的共识节点看到的都是这一相同的区块树。此外，伴随着协议的进程，区块树中总会有一条最终确定区块的路径。同样地，诚实的共识节点对这一路径有一致的视角：尽管每个共识节点可能对这条路径有不同的局部视角，但是所有的共识节点看到的都是这一相同的路径。沿着这条路径的区块有效负载中的输入，是已经排序好的输入并将由IC的执行层进行处理。

&emsp;&emsp;IC的共识协议按照轮次进行处理。在轮次h中，一个或多个高度为h的区块被添加到区块树中。也就是说，在第h轮添加的区块，距离根节点的距离都是h。在每一轮中，将通过伪随机过程给每一个共识节点分配一个唯一的排名，范围是0,...,n-1的整数。这一伪随机过程使用了随机信标(Random Beacon，使用了阈值签名技术，在章节1.6.1中已经提及并将在第3章进行详细介绍)来实现。排名最低的共识节点是该轮次的主节点。当主节点是诚实节点并且网络同步时，主节点会提议一个新区块，并加入到区块树中；此外，这将会是在该轮次唯一添加到区块树的区块，并扩展最终确定区块的路径。如果主节点不是诚实节点或者网络不同步状态，其他排名更高的共识节点也可能提议新区块，并将其添加到区块树中。无论是哪种情况，协议中主节点提议的区块仍会给予最高优先级，其他提议的区块在这一轮也会被加入到区块树中去。即使协议处理多轮后没有扩展最终确定区块的路径，区块树的高度也会随着每一轮继续增长，这样的话当在第h轮最终区块确定区块路径扩展时，其长度也将达到h。这样做的好处是，即使因为故障节点或者意外的高网络延迟到导致更长的等待时间，协议的吞吐量仍可以基本保持不变。

&emsp;&emsp;共识协议依赖于电子签名在共识节点中去验证消息。为实现这一点，每一个共识节点都与签名协议的一个公钥相关联。而共识节点和公钥之间的关联关系可以从NNS维护的注册表中获取。

## 2.3 消息路由

如章节1.7中所述，IC中的基本计算单元叫做容器。IC提供了运行环境，使得容器中可以执行程序，并可以通过消息与其他容器和外部用户通信。

&emsp;&emsp;共识层将输入打包进区块的有效负载中，并随着区块被确定，对应的有效负载被传入消息路由层，然后被执行层处理。执行层将随之更新状态机副本上容器的状态并生成输出，并交由消息路由层处理。

&emsp;&emsp;我们有必要区分两种输入类型：

**入口消息：** 由外部用户发起的消息

**跨子网消息：** 由其他子网的容器发起的消息

&emsp;&emsp;我们同样可以区分两种输出类型：

**入口消息响应：** 对于入口消息的响应（有可能被外部用户取回）

**跨子网消息：** 传输给其他子网容器的消息

&emsp;&emsp;在收到共识层的有效负载后，其中的输入消息将会分配到不同输入队列中。对于每个子网上的每一个容器C而言，有这些输入队列：一个队列负责向容器C发起的入口消息，对于每一个与容器C通信的容器C'都会有一个单独的队列，负责从容器C'向容器C发起的跨子网消息。

&emsp;&emsp;在每一轮中，执行层会处理输入队列中的一部分消息，并更新状态机的副本状态(replicated state)，将输出消息放入队列中。对于每个子网上的每一个容器C而言，有这些输出队列：对于每一个与容器C通信的容器C'都会有一个单独的队列，负责从容器C向容器C'发起的跨子网消息。消息路由层会提取输出队列中的消息，将其放置到子网间信息流(subnet-to-subnet streams)中，由跨子网传输协议(crossnet transfer protocol)进行处理，跨子网传输协议的主要任务就是传输这些消息给其他子网。

&emsp;&emsp;除了这些输出队列之外，还有一个入口消息历史的数据结构。一旦一个入口消息被容器处理后，对该入口消息的响应将会在这一数据结构中进行记录。此时，发起该入口消息的外部用户就可以获取对应的响应（注意入口消息历史不会保留所有入口消息的历史记录）。

&emsp;&emsp;需要注意的是，节点副本的状态包括容器的状态以及“系统状态”。“系统状态”包括上述提及的队列，信息流以及入口消息历史。因此，消息路由层和执行层同时负责更新和维护子网的副本状态。此时就必须确保以完全确定的方式更新这一状态，这样所有共识节点保持完全相同的状态。

&emsp;&emsp;另外需要注意的是，共识层和消息路由层以及执行层是解耦的，也就是说传入有效负载之前，共识区块链中的任何分叉都已经被解决了。事实上，共识层允许提前运行，并不需要和消息路由层保持完全一致的进度。

### 2.3.1 单轮验证状态(Per-round certified state)

在每一轮中，子网的一部分状态会被验证。单轮验证状态采用链钥加密技术进行验证。除了一些别的之外，给定轮次中的验证状态包括

- 最近添加到子网间信息流中的跨子网消息
- 其他元数据，包括入口消息历史的数据结构

单轮验证状态利用了阈值签名技术验证（详见章节1.6.1）。在IC中单轮验证状态被用于如下几个方面：

- **输出验证.** 跨子网消息和入口消息响应都使用单轮验证状态进行验证。
- **防止和检测不确定性.** 共识层保证了每个共识节点按相同的顺序处理输入消息。因为每个共识节点确定性得处理消息，应当会得到相同的状态。但是IC额外设计了一层确保健壮性，来防止和检测任何意外的不确定性计算的发生。单轮验证状态是该机制中的其中一环。
- **协调共识层.** 单轮验证状态还通过两种方式来协调执行层和共识层：
	- 如果共识层运行快于执行层（进度由上一轮验证状态决定），共识层会被“降速”。
	- 共识层的输入必须经过特定的有效性验证，这些验证取决于所有共识节点已达成共识的验证状态。

### 2.3.2 查询调用(query calls)和更新调用(update calls)

正如我们之前所阐述的，所有的入口消息必须经过共识，才能被子网的所有共识节点按相同的顺序进行处理。但是，针对那些处理时不会变更状态的入口消息，可以进行一项重要的优化。这些不会变更状态的入口消息即查询调用，相对地，其他入口消息被称为更新调用。查询调用允许读取和可能更新一个容器的状态，但是任何对该容器的状态更新都不会提交到副本状态中。因此，一个查询调用可以一个单独的共识节点进行处理，而不需要进入共识。这大大缩短了获取查询调用的响应时间。

&emsp;&emsp;一般而言，对查询调用的响应不会记录在入口消息历史的数据结构中，因此也不可以用之前的单轮验证状态进行验证。然而，IC使容器可以存储数据（在处理更新调用时）在特殊的验证变量中(certified variables)，可以利用这一机制验证数据的有效性；这样的话，查询调用可以返回值并存储在一个验证变量中，仍然可以被验证。

### 2.3.3 外部用户认证(External user authentication)

入口消息和跨子网消息的一个主要区别在于用于验证消息的机制。链钥加密技术用于验证跨子网消息，另一个不同的机制用于外部用户发起的入口消息。

&emsp;&emsp;IC中没有外部用户的中央注册表。相反，外部用户通过一串公钥哈希作为用户标识符来向容器来标识自己。用户自己持有对应的签名密钥，用来签署入口消息。签名和公钥会随着入口消息一起发送。IC将自动验证签名并传递用户标识符给到对应的容器。随后该容器根据用户标识符和入口消息中指定操作的其他参数，批准请求的操作。

&emsp;&emsp;新用户在首次与IC交互时会生成密钥对并获取他们的用户标识符。老用户根据存储在用户端的私钥进行验证。用户还可以用签名委托的方式，将多个密钥对关联到一个用户身份上。这很有用，因为它允许用户可以在多个设备使用上同一个用户身份。

## 2.4 执行层

执行层一次处理一个输入消息。这一输入消息取自输入消息队列，并定向到指定的容器。根据次输入消息和该容器的状态，执行层环境将更新容器的状态，另外将消息加入输出队列并更新入口消息历史（可能包括对更早的入口消息的响应）。

&emsp;&emsp;每个子网都可以访问分布式伪随机发生器(PRG)。二进制伪随机数的种子是被称为随机磁带(Random Tape)(参见章节1.6.1，详见第3章)的阈值签名。共识协议的每一轮都会有一个不同的随机磁带。

&emsp;&emsp;随机磁带的基本特性有

1. 在区块高度为h的区块被任意诚实节点确认之前，区块高度h+1的随机磁带是不可预测的。
2. 在区块高度为h+1的区块被任意诚实节点确认的时间点前，共识节点已经有构建区块高度h+1的随机磁带的所有要素

&emsp;&emsp;例如在h轮时，子网为获得二进制伪随机数，需要向执行层发起“系统请求”。系统随后将用高度h+1的随机磁带进行响应。根据上述的特性(1)，协议保证在子网发送请求时，请求的二进制伪随机数不可预测。根据上述的特性(2)，请求的二进制伪随机数通常会在下一个区块被确认时可用。

## 2.5 组合在一起

我们追踪一个用户请求在IC上的典型流程。

1. 用户通过用户端向边界节点（详见章节1.9）发送对于容器C的请求消息M，边界节点将消息M发送给托管着容器C的子网共识节点。

2. 接收到消息M后，该共识节点通过P2P层（详见章节2.1）向子网中的所有共识节点广播消息M。

3. 在接收到消息M的情况下，共识层下一轮的主节点（详见章节2.2）会将消息M和其他输入一同打包进其提议的区块B。

4. 一段时间之后，区块B被最终确认，其有效负载被发送至消息路由层（详见章节2.3）进行处理。需要注意的是，P2P层同样用于共识协议去确认区块。

5. 消息路由层会将消息放置在容器C的输入消息队列中。

6. 一段时间之后，执行层（详见章节2.4）会处理消息M，并更新容器C的内部状态。

	在一些情况下，容器C能够计算对于请求消息M的响应R。在这种情况下，响应R会被记录在入口消息的数据结构中。

	在其它情况下，处理请求消息M需要向别的容器调用请求。在这个例子中，我们假设为处理请求消息M，容器C需要向另一个子网的另一个容器C'调用请求M'。这第二个请求M'会被放置在容器C的输出队列中，然后接下去的几步将被执行。

7. 一段时间之后，消息路由层会将调用请求M'移动到合适的跨子网信息流中，最终将会被传输到托管容器C'的子网。

8. 在第二个子网中，获取来自第一个子网的请求M'后，其会通过共识层和消息路由，最终由执行层进行处理。第二个子网的执行层会更新容器C'的内部状态，然后生成对于请求M'的响应R'。响应R'会进入容器C'的输出队列，最终放置在跨子网信息流中被传输回第一个子网。

9. 回到第一个子网，获取来自第二个子网的响应R'后，其会通过共识层和消息路由，最终由执行层进行处理。第一个子网的执行层会更新容器C的内部状态，然后生成对于原始请求M的响应R。这一响应R会被记录在入口消息的数据结构中。

&emsp;&emsp;无论是哪条执行路径，对于请求消息M的响应R，最终会被记录在托管容器C的子网的入口消息历史数据结构中。为了获取这一响应结构，用户端必须执行“查询调用”（详见章节2.3.2）。就像在章节2.3.1中所阐述的，这一响应可以被链钥加密技术（具体来说，使用的是阈值签名技术）进行验证。用户端执行的这一验证逻辑本身（即阈值签名认证），可以通过最初从边界节点获取的服务进行执行。
